<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.2.3 -->
<title>Pointers In C | [“Knowledge Base”]</title>
<meta property="og:title" content="Pointers In C" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="[“Useful information on a wide variety of topics for software development”]" />
<meta property="og:description" content="[“Useful information on a wide variety of topics for software development”]" />
<link rel="canonical" href="http://localhost:4000/cprogramming/pointers/" />
<meta property="og:url" content="http://localhost:4000/cprogramming/pointers/" />
<meta property="og:site_name" content="[“Knowledge Base”]" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"WebPage","headline":"Pointers In C","description":"[“Useful information on a wide variety of topics for software development”]","url":"http://localhost:4000/cprogramming/pointers/"}</script>
<!-- End Jekyll SEO tag -->

    <link href='https://fonts.googleapis.com/css?family=Arvo:400,700,400italic' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <script src="/assets/js/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header"><a href="/">Knowledge Base</a></h1>
        <p class="header">Useful information on a wide variety of topics for software development</p>
        
        <ul class="nav">
          <li class="current"><a href="/cprogramming">C/C++</a></li>
          <li><a href="#">PHP</a></li>
        </ul>

        <ul>
          
        </ul>

        


      </header>

      <section>
        <h1 id="pointers-in-c">Pointers In C</h1>

<p>Pointers are one of the most dreaded topics in C but also one of the most useful.
This tutorial attempts to explain the basics of pointers so you can gain better understanding and make best use of them.</p>

<h2 id="what-is-a-pointer">What is a pointer?</h2>
<p>A pointers is simply a variable that stores the address of another variable.
Variables are stored in memory locations that have addresses. 
When you declare a variable in a C program, the compiler sets aside a memory location with a unique address to store that variable. The compiler associates that address with the variable’s name. When your program uses the variable name, it automatically accesses the proper memory location.
for example</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre>
</div>
<p>this creates a variable “num” at a certain location in memory. To see that location you use “&amp;” before the variable name</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"Address of num: %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
</code></pre>
</div>

<p>output will be something like</p>

<p><strong>Address of num: 0x7ffcf8949fb4</strong></p>

<p>##Declaring pointers and assigning values
Declaring a pointer follows the same conventions as regular variables except you use “*” before the variable name</p>

<p><code class="highlighter-rouge">typename *ptrname;</code></p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">ptr_num</span><span class="p">;</span>
</code></pre>
</div>

<p>This creates a variable ptr_num that will be used to hold the address of an integer variable.
 Pointers take addresses as their values. To assign values to a pointer</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="c1">//initialization
</span> <span class="kr">typename</span> <span class="o">*</span><span class="n">ptr_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">variable</span><span class="p">;</span> 
<span class="c1">// assignment
</span> <span class="n">ptr_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">variable</span><span class="p">;</span>
</code></pre>
</div>

<h2 id="using-pointers">Using Pointers</h2>
<p>When using pointers, the indirection operator (*) comes into play. When the * precedes the name of a pointer, it refers to the variable pointed to.
Lets try out an example</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">num_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"The value of num is:</span><span class="se">\t\t</span><span class="s"> %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>	
	<span class="n">printf</span><span class="p">(</span><span class="s">"The value of num from num_ptr:</span><span class="se">\t</span><span class="s"> %d</span><span class="se">\n\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">num_ptr</span><span class="p">);</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"The address of num:</span><span class="se">\t\t</span><span class="s"> %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"The value of num_ptr:</span><span class="se">\t</span><span class="s"> %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_ptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The \t is simply a tab character for formatting reasons. From the output you see that the values are the same depending on how you use it.<br />
 Note: a pointer is also a variable so &amp;ptr_name will give you the address of the pointer variable itself. 
 Since it’s a variable you can also point to its address with a pointer to a pointer
 typename **ptr_name;
 we will see some examples of this with strings and arrays</p>

<h2 id="arrays-and-pointer-arithmetics">Arrays and Pointer arithmetics</h2>

<p>An array is a collection of elements of the same datatype is contiguous memory locations.
 You should already know about arrays and how to use them.
 The interesting thing about arrays is the array variable is also actually a pointer to the first element in the array
int num_arr[10] = { 2, 3, 4, 5, 6 };
num_arr variable contains the memory address of the first element which is 2</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"First element is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Value of *num_arr is: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">num_arr</span><span class="p">);</span>
 
<span class="n">printf</span><span class="p">(</span><span class="s">"Address of num_arr[0]:</span><span class="se">\t</span><span class="s"> %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"Value of num_arr is:</span><span class="se">\t</span><span class="s"> %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num_arr</span><span class="p">);</span>
</code></pre>
</div>
<p>From the output you see that they are the same. And for sure
 num_arr holds address of num_arr[0]
 num_arr  is  &amp;num_arr[0]
 *num_arr  is  num_arr[0]</p>

<p>Knowing this, introduces an interesting concept of pointer arithmetic.
 Since arrays are in contiguous memory locations, if say an integer takes 4 bytes
 num_arr[1] will be at location num_arr + 4
 num_arr[2] will be at location num_arr + 4*2
You don’t actually need to know the size a datatype takes up in memory to be able to do pointer arithmetic because the compiler knows and does all that for you
 therefore
num_arr + 1 will be location of num_arr[1]
 (Infact that is why array indices start at 0, so that the index can be used as an offset to quickly and efficiently retrieve data)
*(num_arr + 2) is the same as num_arr[2]</p>

<p>You can also do subtraction.
 The compiler actually expands num_arr[3] into *(num_arr + 3) so you can infact do something like 3[num_arr] and it would still work because 3[num_arr] would be expanded to *(3 + num_arr)
 try it out. Its not a lie. 
 As cool as it may seem, I think its best to just forget about pointer arithmetic so that you don’t run into problems of trying to access memory locations that don’t exist. You know about it. Now forget it.</p>

<h2 id="strings">Strings</h2>
<p>A String as you already know, is an array of characters ending with null character.<br />
All the knowledge from arrays applies, however strings present an issue of mutability. 
 Simply put immutable means it cannot be changed while mutable means it can be changed</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">"Immutable string"</span><span class="p">;</span>
</code></pre>
</div>
<p>the data “Immutable string” is declared in data section and cannot be changed. The pointer however can be changed to point to something else and when that happens you may lose access to “Immutable string” and it will stay there lonely with no one to call it.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Mutable string"</span><span class="p">;</span>
</code></pre>
</div>
<p>this time the data can be changed. It seems weird but it’s very important to remember.</p>

<p>It is difficult to explain but think of it like this.
 When you declare a variable, memory is allocated and space is reserved for that variables data.
 When you declare a pointer, the memory location is only able to hold an address.
For example if addresses are of size 4 (they are actually like 64 bytes but just follow along), an integer could be of size 8. 
 An integer variable will be of size 8 and an integer pointer variable will be of size 4. addresses are of the same size.
<code class="highlighter-rouge">char str[] = "Mutable string";</code> 
 this creates a character array variable and the contents of the string are stored in the array</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">"Immutable string"</span><span class="p">;</span>
</code></pre>
</div>
<p>this creates a character pointer variable and since the string has no space allocated to it, it is stored in a part of your programs memory called the data section and the address to it is stored in the pointer. Data in the data section cannot be changed. 
 This works for strings because they were designed that way. Don’t just try it on other data types.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="c1">//this will not work
</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_arr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</code></pre>
</div>
<p>To demonstrate immutability, Lets try changing “hello” to “jello”</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'j'</span><span class="p">;</span>   

<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</code></pre>
</div>
<p>As expected the first character ‘h’ is replaced with ‘j’. Doing *str = ‘j’; would yield same result. With immutable strings it would fail miserably with a segmentation fault.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'j'</span><span class="p">;</span> 
 
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</code></pre>
</div>
<p>Such a seg fault is a runtime error which is not caught at compile time. Thats why developers like to use const on immutable variables.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
<span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'j'</span><span class="p">;</span> 
 
<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</code></pre>
</div>
<p>The above generates a compile time error which is what we like to see. not seg faults. Get into the habit of using const for immutable strings.
The elements of the immutable string cannot be changed, however, the pointer can be changed to point to something else.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hubby</span> <span class="o">=</span> <span class="s">"wifey"</span><span class="p">;</span>
<span class="n">hubby</span> <span class="o">=</span> <span class="s">"sidechick"</span><span class="p">;</span>
</code></pre>
</div>
<p>“sidechick” just replaced “wifey” and now shes lonely with no way to access her anymore.
 What do we do when we don’t want to lose access to “wifey”? We use constant pointers. 
 The previous const was pointers to a constant.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="c1">// pointers to a constant
</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hubby</span> <span class="o">=</span> <span class="s">"wifey"</span><span class="p">;</span>

<span class="c1">//constant pointer
</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">hubby</span> <span class="o">=</span> <span class="s">"wifey"</span><span class="p">;</span>
</code></pre>
</div>
<p>With a constant pointer, Now he cant leave her.</p>

<h2 id="functions">Functions:</h2>
<p>You should be familiar with functions and passing by value. Passing by value means the value of the variable is passed into the function and not the variable itself.</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">increment</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</code></pre>
</div>
<p>there are times when we wish to change the original value outside of the function. With pointers we can just pass the address of the variable to be changed</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">magicfix</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">number</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="n">number</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">magicfix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
</code></pre>
</div>
<p>This is usually done to improve efficiency and save memory. Instead of passing large values around, instead pass their address. Really effective for strings and structs.
 You notice it with functions like scanf</p>

<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
<span class="n">scanf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">str1</span><span class="p">);</span>
</code></pre>
</div>
<p>Yes a string is sort of a pointer.</p>

<h2 id="function-pointers">Function Pointers</h2>
<p>Much like variables, functions also have addresses so you can have pointers to functions. Function pointers follow a stranger format though because in addition to return type, you also have to specify the function parameter types.</p>

<p><code class="highlighter-rouge">returntype (*func_ptr_name) (parameter_type …)</code></p>

<p>Lets try out an example.</p>
<div class="language-c highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sleep</span><span class="p">(</span><span class="kt">int</span> <span class="n">hours</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d hours of sleep can save the soul</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hours</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">nap</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">);</span>
	<span class="n">nap</span> <span class="o">=</span> <span class="n">sleep</span><span class="p">;</span>
	<span class="n">nap</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>This enables you to achieve call back functionality where you pass a function address to a function and it calls it or many other things you can think of</p>

      </section>

      <footer>
        <p><small>This project is maintained by <a href="">Code Plates</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
